diff --git a/src/enc/frame.c b/src/enc/frame.c
index 7885e55..f0f4300 100644
--- a/src/enc/frame.c
+++ b/src/enc/frame.c
@@ -33,8 +33,8 @@
 typedef struct {  // struct for organizing convergence in either size or PSNR
   int is_first;
   float dq;
-  float q, last_q;
-  double value, last_value;   // PSNR or size
+  float q, max_q, min_q;
+  double value, max_value, min_value;   // PSNR or size
   double target;
   int do_size_search;
 } PassStats;
@@ -46,11 +46,13 @@ static int InitPassStats(const VP8Encoder* const enc, PassStats* const s) {
 
   s->is_first = 1;
   s->dq = 10.f;
-  s->q = s->last_q = enc->config_->quality;
+  s->q = 90; // start with 90% quality for interpolation
+  s->min_q = 0;
+  s->max_q = 90;
   s->target = do_size_search ? (double)target_size
             : (target_PSNR > 0.) ? target_PSNR
             : 40.;   // default, just in case
-  s->value = s->last_value = 0.;
+  s->value = s->max_value = s->min_value = 0;
   s->do_size_search = do_size_search;
   return do_size_search;
 }
@@ -60,21 +62,28 @@ static float Clamp(float v, float min, float max) {
 }
 
 static float ComputeNextQ(PassStats* const s) {
-  float dq;
+  double slope;
+
+  // first pass uses quality 90% to set up interpolation
+  //  - image may already be below required size.
   if (s->is_first) {
-    dq = (s->value > s->target) ? -s->dq : s->dq;
-    s->is_first = 0;
-  } else if (s->value != s->last_value) {
-    const double slope = (s->target - s->value) / (s->last_value - s->value);
-    dq = (float)(slope * (s->last_q - s->q));
+	s->is_first = 0;
+	if (s->value < s->target) return s->q;
+  }
+
+  if (s->value > s->target) {
+	s->max_value = s->value;
+	s->max_q = s->q;
   } else {
-    dq = 0.;  // we're done?!
+	if (s->target - s->value < 10)
+		return s->q;
+	s->min_value = s->value;
+	s->min_q = s->q;
   }
-  // Limit variable to avoid large swings.
-  s->dq = Clamp(dq, -30.f, 30.f);
-  s->last_q = s->q;
-  s->last_value = s->value;
-  s->q = Clamp(s->q + s->dq, 0.f, 100.f);
+  slope = (s->max_q - s->min_q) / (s->max_value - s->min_value);
+  s->dq = (float)(0.8 * slope * (s->target - s->min_value));
+
+  s->q = Clamp(s->min_q + s->dq, 0.f, 100.f);
   return s->q;
 }
 
@@ -611,7 +620,7 @@ static int StatLoop(VP8Encoder* const enc) {
     if (size_p0 == 0) return 0;
 #if (DEBUG_SEARCH > 0)
     printf("#%d value:%.1lf -> %.1lf   q:%.2f -> %.2f\n",
-           num_pass_left, stats.last_value, stats.value, stats.last_q, stats.q);
+           num_pass_left, stats.max_value, stats.value, stats.max_q, stats.q);
 #endif
     if (enc->max_i4_header_bits_ > 0 && size_p0 > PARTITION0_SIZE_LIMIT) {
       ++num_pass_left;
@@ -815,8 +824,8 @@ int VP8EncTokenLoop(VP8Encoder* const enc) {
 
 #if (DEBUG_SEARCH > 0)
     printf("#%2d metric:%.1lf -> %.1lf   last_q=%.2lf q=%.2lf dq=%.2lf\n",
-           num_pass_left, stats.last_value, stats.value,
-           stats.last_q, stats.q, stats.dq);
+           num_pass_left, stats.max_value, stats.value,
+           stats.max_q, stats.q, stats.dq);
 #endif
     if (size_p0 > PARTITION0_SIZE_LIMIT) {
       ++num_pass_left;
